package com.sri.apps.netsim;


import java.io.*;
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.net.*;
import java.util.*;
import com.sri.utils.*;
import com.sri.utils.adt.*;
import com.sri.gui.ext.drawing.*;

/***    XML Classes     ***/
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xerces.parsers.*;

/**
 * The Network where all the devices are running.
 *
 * This is where all NetworkEntities are "run".
 *
 * This object is what maintains the global time and executes all
 * NetworkEntities at given time slots.
 *
 * One question remains.  Is a Network a NetworkEntity?
 */
public class Network implements Runnable
{
        /**
         * The event queue.
         */
    protected EventQueue eventQueue = null;

        /**
         * The scheduler that processes the events one by one.
         */
    protected Thread scheduler = null;

        /**
         * The network entities that are part of this network
         * world.
         */
    protected NetworkEntity netEntities[];
    protected int nEntities;

        /**
         * The granularity of this network.
         * This is basically the view with "observations" are taken.
         */
    protected int viewGranularity;

        /**
         * Tells if the scheduler is runing.
         */
    protected boolean schedulerRunning = false;
        
        /**
         * Set to false when the scheduler is stopped.
         */
    protected boolean schedulerStopped = false;

        /**
         * The network starts.
         * The scheduler is started and then all the devices are started.
         */
    public synchronized void start()
    {
        if (scheduler == null) scheduler = new Thread(this);

        if (scheduler != null &&
                (schedulerRunning && !schedulerStopped)) return ;

            // check that the event queue is running...
        eventQueue = new EventQueue();

            // run the event processor...
        scheduler.start();

        schedulerRunning = true;
        schedulerStopped = false;

            // start each network entity...
        for (int i = 0;i < nEntities;i++)
        {
            netEntities[i].start(this, eventQueue.currTime);
        }
    }

        /**
         * The network stops.
         */
    public synchronized void stop()
    {
        if (scheduler != null && schedulerRunning && !schedulerStopped)
        {
            schedulerStopped = true;
            notifyAll();

            while (schedulerRunning)
            {
                try
                {
                    wait();
                } catch (Exception ex)
                {
                }
            }

            schedulerStopped = schedulerRunning = false;
            notifyAll();
        }

            // stop each network entity...
        for (int i = 0;i < nEntities;i++)
        {
                // the curr time here should not be 0!!!
            netEntities[i].stop(this, eventQueue.currTime);
        }
    }

        /**
         * Main run method for the scheuler.
         */
    public void run()
    {
        synchronized (this)
        {
            SimEvent nextEvent = null;
            while (schedulerRunning && !schedulerStopped)
            {
                nextEvent = eventQueue.nextEvent();

                    // wait till an event is available
                while (nextEvent == null)
                {
                    try 
                    {
                        wait();
                    } catch (Exception ex)
                    {
                    }
                    nextEvent = eventQueue.nextEvent();
                }

                    // process the request...
                if (nextEvent.dest != null && nextEvent.dest.isRunning())
                {
                        // temporarily set the current network time to
                        // the time of the current event this is done so
                        // that any events generated by this event handler
                        // can be verified to have the right time when we
                        // are in the "getTime" function... with this
                        // approach two things are to be noted:
                        //
                        // 1) currTime will be monotonically increasing if
                        // the event queue isordered by the target time of
                        // the events.
                        //
                        // 2) If the currTime is not monotonically
                        // increasing, this is no big deal because all we
                        // would see is "jump" in time.
                    eventQueue.currTime = nextEvent.targetTime;
                    nextEvent.dest.handleEvent(nextEvent,
                                               nextEvent.targetTime,
                                               this);
                }
            }
        }
    }

        /**
         * Adds a new event to the event queue.
         */
    public void addEvent(SimEvent event)
    {
        eventQueue.addEvent(event);
    }

        /**
         * Add a network entity.
         */
    public void addNetworkEntity(NetworkEntity ne)
    {
    }

        /**
         * Removes the network entity.
         */
    public void removeNetworkEntity(NetworkEntity ne)
    {
    }
}
