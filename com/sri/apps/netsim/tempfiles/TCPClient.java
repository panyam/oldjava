package com.sri.apps.netsim;

/**
 * Basically this class is a connection or a TCP session that is
 * generated by a host.
 * This only represents a TCP client object.  So this can be extended by
 * each protocol as we want.
 */
public abstract class TCPClient extends PortClient
{

    boolean synAckReceived = false;
    boolean synPacketSent = false;

        /**
         * Constructor.
         */
    public TCPClient(HostModule host)
    {
            // initally we set the port to -1 
            // as the port will be automatically assigned
            // by the hsot object...
        super(host);
    }

        /**
         * Connects to a given server on a given
         * port.
         * Basically a connection can be refused
         * if the server is not up or for any other 
         * reason.
         * So send a syn packet with the mac addresses
         * and the 
         * One might be wondering why we need the destination MAC address.
         * Techincally you dont.  But then we need to be coding
         * ARP requests and this is too much work for this project.
         * But this is a good extention.  The host can send out
         * arp requests and so on.  So we are going with this
         * simple hack for now...
         */
    public synchronized int connectTo(long destMac, int serverIP, int dport)
        throws Exception
    {
        if (synPacketSent) return -1;

        Device parentDevice = hostModule.parent;

        this.serverIP = serverIP;
        serverPort = dport;
		this.destMac = destMac;

        synAckReceived = false;

        Packet synPacket = TCPUtils.createPacket(128);

            // basically the dstMac and the srcMac would
            // be reverse of the the packet we 
            // recieved...
        //EthernetUtils.writeSrcMac(synPacket, routerInterface.macAddress);
        EthernetUtils.writeDestMac(synPacket, destMac);

            // same deal with the IP addresses
        //IPUtils.writeSrcIP(synPacket, routerInterface.ipAddress);
        IPUtils.writeDestIP(synPacket, serverIP);

        IPUtils.writeLength(synPacket,
                            TCPUtils.TCP_OFFSET + TCPUtils.TCP_HLENGTH);

        TCPUtils.writeSrcPort(synPacket, this.port);
        TCPUtils.writeDestPort(synPacket, serverPort);

            // set the syn flags...
        TCPUtils.setFlag(synPacket, TCPUtils.SYN_FLAG);

        synPacket.packetModule = hostModule;
        hostModule.parent.transmitPacket(synPacket);
        synPacketSent = true;
        return 0;
    }

        /**
         * Disconnect the connection.
         */
    public void disconnect() throws Exception
    {
        if (synAckReceived)
        {
            synPacketSent = false;
            synAckReceived = false;
            Device parentDevice = hostModule.parent;


                // send a fin flag..

            Packet finPacket = TCPUtils.createPacket(128);

                // basically the dstMac and the srcMac would
                // be reverse of the the packet we 
                // recieved...
            //EthernetUtils.writeSrcMac(finPacket, routerInterface.macAddress);
            EthernetUtils.writeDestMac(finPacket, destMac);

                // same deal with the IP addresses
            //IPUtils.writeSrcIP(finPacket, routerInterface.ipAddress);
            IPUtils.writeDestIP(finPacket, serverIP);

            IPUtils.writeLength(finPacket,
                            TCPUtils.TCP_OFFSET + TCPUtils.TCP_HLENGTH);

            TCPUtils.writeSrcPort(finPacket, this.port);
            TCPUtils.writeDestPort(finPacket, serverPort);

                // set the syn flags...
            TCPUtils.setFlag(finPacket, TCPUtils.FIN_FLAG);

            finPacket.packetModule = hostModule;
            hostModule.parent.transmitPacket(finPacket);

                // also ask the parent device to remove ourself
                // from the list of running clients...
                // then kill the application..
                // so it can be removed from the host
            hostModule.removeClient(this);
        }
    }

        /**
         * Called when a packet arrives for this service.
         */
    public synchronized void processPacket(Packet packet)
        throws Exception
    {
            // if we are not synPacketSent then dont do anything...
        if (!synPacketSent) return ;

        int srcPort = TCPUtils.readSrcPort(packet);
        int serverIP = IPUtils.readSrcIP(packet);

            // check where the packet is coming from
            // could be dodgy packets coming from anywhere
        if (this.serverIP != serverIP ||
            this.serverPort != srcPort)
        {
            return ;
        }

            // if the synflag of the packet is set
            // and if the client index is valid then 
            // ignore the packet because it is invalid...
            // basically this is what happens with syn-flooding
            //
            // another check we should be doing is to look
            // for dodgy flag optiosn like syn and fin set
            // or so on.  Once again, this is not an issue
            // as we are simulating firewalls rather than
            // gateways or host functionality
        if (TCPUtils.isFlagSet(packet, TCPUtils.SYN_FLAG) &&
            TCPUtils.isFlagSet(packet, TCPUtils.ACK_FLAG))
        {
            if (synAckReceived)
            {
                return ;
            } else
            {
                synAckReceived = true;
                startProtocolBasedCommunication();
            }
        } else if (TCPUtils.isFlagSet(packet, TCPUtils.FIN_FLAG))
        {
                // then disconnect
            disconnect();
        } else if (synAckReceived)
        {
                // then let the client
                // take care of this packet...
                // this means that at this stage, 
                // this packet is part the actual
                // session itself...
            handleSessionPacket(packet);
        }
    }

        /**
         * Called once, after the syn-ack packet is received
         * so taht we can start sending data or receiving 
         * data and so on.
         */
    protected abstract void startProtocolBasedCommunication() throws Exception;

        /**
         * Write the payload with a single byte.
         * This is totally specialised for this protocol
         * but what the heck.
         */
    public void writePayload(byte byteVal)
        throws Exception
    {
        if (synAckReceived)
        {
            int l = 1 + TCPUtils.TCP_OFFSET + TCPUtils.TCP_HLENGTH;
            Packet outPacket = TCPUtils.createPacket(l + 5);

            IPUtils.writeLength(outPacket, l);

			//EthernetUtils.writeSrcMac(outPacket, routerInterface.macAddress);
			EthernetUtils.writeDestMac(outPacket, destMac);
			
            //IPUtils.writeSrcIP(outPacket, routerInterface.ipAddress);
            IPUtils.writeDestIP(outPacket, serverIP);

            TCPUtils.writeSrcPort(outPacket, this.port);
            TCPUtils.writeDestPort(outPacket, serverPort);

            outPacket.data[TCPUtils.TCP_DATA_OFFSET] = byteVal;

            outPacket.packetModule = hostModule;
            hostModule.parent.transmitPacket(outPacket);
        }
    }

        /**
         * Appends the payload to to the TCP packet
         * and writes it to the interface.  Happesn
         * only if we are connected
         */
    public void writePayload(byte data[], int length)
        throws Exception
    {
        if (synAckReceived)
        {
            int l = length + TCPUtils.TCP_OFFSET + TCPUtils.TCP_HLENGTH;
            Packet outPacket = TCPUtils.createPacket(l + 10);

            IPUtils.writeLength(outPacket, l);

			//EthernetUtils.writeSrcMac(outPacket, routerInterface.macAddress);
			EthernetUtils.writeDestMac(outPacket, destMac);
			
            //IPUtils.writeSrcIP(outPacket, routerInterface.ipAddress);
            IPUtils.writeDestIP(outPacket, serverIP);

            TCPUtils.writeSrcPort(outPacket, this.port);
            TCPUtils.writeDestPort(outPacket, serverPort);

            System.arraycopy(data, 0,
                             outPacket.data, TCPUtils.TCP_DATA_OFFSET,
                             length);

            outPacket.packetModule = hostModule;
            hostModule.parent.transmitPacket(outPacket);
        }
    }

        /**
         * Basically this is what is extended by each protocol.
         */
    protected abstract void handleSessionPacket(Packet packet) 
        throws Exception;
}
